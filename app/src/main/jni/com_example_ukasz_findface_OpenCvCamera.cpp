/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_example_ukasz_findface_OpenCvCamera.h"

JNIEXPORT void JNICALL Java_com_example_ukasz_findface_OpenCvCamera_faceDetector
  (JNIEnv *, jclass, jlong camRgba) {
    Mat& image = *(Mat*)camRgba;


   detectFace(image);
}

JNIEXPORT void JNICALL Java_com_example_ukasz_findface_OpenCvCamera_blackWhiteMode
(JNIEnv *, jclass, jlong camRgba) {
    Mat& image = *(Mat*)camRgba;


    blackWhiteMode(image);
}

JNIEXPORT void JNICALL Java_com_example_ukasz_findface_OpenCvCamera_moveDetector
(JNIEnv *, jclass, jlong camRgba) {
    Mat& image = *(Mat*)camRgba;


    detectMove(image);
}

JNIEXPORT void JNICALL Java_com_example_ukasz_findface_OpenCvCamera_moveDetectorBetter
(JNIEnv *, jclass, jlong camRgba) {
Mat& image = *(Mat*)camRgba;


detectMoveBetter(image);
}

JNIEXPORT void JNICALL Java_com_example_ukasz_findface_OpenCvCamera_lightDetector
(JNIEnv *, jclass, jlong camRgba) {
    Mat& image = *(Mat*)camRgba;


    detectLight(image);
}

void blackWhiteMode(Mat& image) {
    cvtColor(image, image, COLOR_BGR2GRAY);
}

void detectFace(Mat& frame) {



//    String face_cascade_name = "haarcascade_frontalface_alt.xml";
//    String eyes_cascade_name = "haarcascade_eye_tree_eyeglasses.xml";
//    CascadeClassifier face_cascade;
//    CascadeClassifier eyes_cascade;
//
//    std::vector<Rect> faces;
//    Mat frame_gray;
//
//    cvtColor( frame, frame_gray, COLOR_BGR2GRAY );
//    equalizeHist( frame_gray, frame_gray );
//
//    //-- Detect faces
//    face_cascade.detectMultiScale( frame_gray, faces, 1.1, 2, 0|CASCADE_SCALE_IMAGE, Size(30, 30) );
//
//    for( size_t i = 0; i < faces.size(); i++ )
//    {
//        Point center( faces[i].x + faces[i].width/2, faces[i].y + faces[i].height/2 );
//        ellipse( frame, center, Size( faces[i].width/2, faces[i].height/2), 0, 0, 360, Scalar( 255, 0, 255 ), 4, 8, 0 );
//
//        Mat faceROI = frame_gray( faces[i] );
//        std::vector<Rect> eyes;
//
//        //-- In each face, detect eyes
//        eyes_cascade.detectMultiScale( faceROI, eyes, 1.1, 2, 0 |CASCADE_SCALE_IMAGE, Size(30, 30) );
//
//        for( size_t j = 0; j < eyes.size(); j++ )
//        {
//            Point eye_center( faces[i].x + eyes[j].x + eyes[j].width/2, faces[i].y + eyes[j].y + eyes[j].height/2 );
//            int radius = cvRound( (eyes[j].width + eyes[j].height)*0.25 );
//            circle( frame, eye_center, radius, Scalar( 255, 0, 0 ), 4, 8, 0 );
//        }
//    }


}

Mat lastImage; // poprzednia klatka
bool first = true;
void detectMove(Mat& image) {
    cvtColor(image, image, COLOR_BGR2GRAY);

    if(first) {
        first = false;
        lastImage = image.clone();
    } else {
        absdiff(image, lastImage, image);
        lastImage = image.clone();
    }

}

bool frst = true;
Mat firstImage; // pierrwsza klatka
void detectMoveBetter(Mat& image) {
    cvtColor(image, image, COLOR_BGR2GRAY);

    if(frst) {
        frst = false;
        firstImage = image.clone();
    } else {
        absdiff(image, firstImage, image);
    }
}

void detectLight(Mat& image) {
    Mat img = image.clone();
   // cvtColor(image, hsv, CV_BGR2HSV);

    int cols = img.size().width;
    int rows = img.size().height;

    for(int i=0; i<rows; i++) {
        for(int l=0; l<cols; l++) {
            Vec3f color = img.at<Vec3b>(i,l);
          //  image.data[image.channels()*(image.rows*i + l)];

            if(color[0] > 230 && color[1] > 235 && color[2] > 218) {
              //  img.at<uchar>(i, l) = 128;
               // image.at<Vec3b>(i,l)[0] = 0;
                color[0] = 0;
                color[1] = 0;
                color[2] = 255;
                img.at<Vec3b>(i,l) = color;

            }

        }
    }

    image = img.clone();


}

